// 用于对纹理进行处理和修改颜色输出。它包含几个操作，例如反转颜色、调节亮度和对 RGB 分量进行加权处理。

precision highp float;
precision mediump sampler2D;

// vUv: 纹理坐标，这通常由顶点着色器传递给片段着色器，表示当前片段的位置。
// uTexture: 输入的纹理，可能是某种图像或图形数据，用 sampler2D 类型来存储。
varying vec2 vUv;
uniform sampler2D uTexture;
void main() {
  // vec3 color = texture2D(uTexture, vec2(1.0 - vUv.y, vUv.x)).rgb * 0.1;

// 使用 texture2D 从纹理 uTexture 中采样颜色值。这里的纹理坐标经过了一些转换：
// 1.0 - vUv.y：反转 y 坐标，使得图像在 y 轴方向上镜像翻转。
// vUv.x 保持不变，表示水平方向不变。
// rgb * 0.1：将颜色值的 RGB 分量乘以 0.1，使得初始颜色变暗。
// color *= 0.5;

// 再次将颜色值乘以 0.5，进一步降低亮度，使颜色变得更暗。
// color = min(color, 0.9);

// 使用 min 函数将颜色分量限制在 0.9 之下。这样做的目的是确保颜色不会超出某个最大值，防止过亮。
// color = vec3(1.0) - color;

// 反转颜色：从 1.0 减去颜色值。这样，原本较暗的部分变亮，而较亮的部分变暗，类似于进行颜色的负片处理。
// color *= vec3(0.95, 0.9, 0.9);

// 对每个颜色分量进行加权调整。红色通道被乘以 0.95，绿色和蓝色通道被乘以 0.9，使得红色略微偏亮，而绿色和蓝色偏暗。这样做可能是为了调整图像的色调，使其更加暖色调或某种特定的色彩效果。
// // color *= 0.5;

// 这一行被注释掉了。如果启用，它将再次降低颜色的亮度。
  vec3 color = texture2D(uTexture, vec2(1.0 - vUv.y,vUv.x)).rgb * 0.1;
  color *= 0.5;
  color = min(color, 0.9);
  color = vec3(1.0) - color;
  color *= vec3(0.95, 0.9, 0.9);
  // color *= 0.5;
  gl_FragColor = vec4(color, 1.0);
}

// 这段代码对输入的纹理进行一系列的颜色处理：

// 镜像翻转：纹理的垂直方向被翻转（1.0 - vUv.y）。
// 降低亮度：通过两次乘法将颜色值降低到较暗的水平。
// 颜色反转：通过 1.0 - color 将颜色值进行反转，类似于做了负片效果。
// 色彩加权：对 RGB 分量进行加权，调整颜色的色调，最终使图像看起来有特定的色彩偏移（红色更亮，绿色和蓝色稍微暗一些）。
// 最终，这段着色器可能会用来生成一种特定的色调或视觉效果，尤其是在纹理映射和颜色处理方面。
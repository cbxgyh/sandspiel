// 片段着色器，它计算了一个基于卷曲（curl）流场的力，并将其应用到当前的速度场。这个力通常用于模拟流体中的旋转或涡流效应。在计算流体力学中，卷曲表示流场的旋转程度，而在此着色器中，卷曲的影响用于调整速度场。
precision highp float;
precision mediump sampler2D;
// uVelocity 和 uCurl：

// uVelocity 是一个纹理，存储了流体场的速度数据，通常是一个 vec2（表示 x 和 y 方向的速度分量）。
// uCurl 是另一个纹理，存储了流体场的卷曲数据。卷曲通常是一个标量值，表示在每个点的旋转程度。
// vUv, vT, vB：

// vUv 是当前片段的纹理坐标，表示当前像素在纹理中的位置。
// vT 和 vB 分别是当前像素的上部和下部纹理坐标，它们通常在计算卷曲时用于计算相邻位置的差异。
// curl 和 dt：

// curl 是一个常数，用来调整卷曲力的强度。
// dt 是时间步长，用于控制速度更新的大小。
varying vec2 vUv;
varying vec2 vT;
varying vec2 vB;
uniform sampler2D uVelocity;
uniform sampler2D uCurl;
uniform float curl;
uniform float dt;
void main() {

  // 卷曲力的计算：

// force = vec2(abs(T) - abs(B), 0.0);：计算上下卷曲值的差异，并将其作为力的大小。T 和 B 分别代表上部和下部卷曲的值。abs 用于计算卷曲的绝对值，防止方向上的负值影响力的大小。
// force *= 1.0 / length(force + 0.00001) * curl * C;：对力进行标准化，避免除以零，C 是当前像素的卷曲值，curl 控制力的强度。
  float T = texture2D(uCurl, vT).x;
  float B = texture2D(uCurl, vB).x;
  float C = texture2D(uCurl, vUv).x;
  vec2 force = vec2(abs(T) - abs(B), 0.0);
  force *= 1.0 / length(force + 0.00001) * curl * C;
  // 更新速度场：

// vec2 vel = texture2D(uVelocity, vUv).xy;：获取当前像素的速度。
// gl_FragColor = vec4(vel + force * dt, 0.0, 1.0);：更新速度场，将计算出的力应用到当前速度，并根据时间步长 dt 更新速度场。
  vec2 vel = texture2D(uVelocity, vUv).xy;
  gl_FragColor = vec4(vel + force * dt, 0.0, 1.0);
}

// 物理背景：
// 卷曲（Curl）：卷曲是一个表示流场旋转的标量，它描述了流体的旋转程度。在流体动力学中，卷曲是一个非常重要的量，它与旋涡、涡流等物理现象密切相关。卷曲的值通常是流体在某一点的旋转速率，常用于描述涡旋、气旋等现象。

// 力的计算：通过计算卷曲值的上下差异，这个着色器模拟了由涡旋（旋转）产生的力。该力影响流体的运动，类似于通过旋涡或其他旋转力场对流体速度的影响。

// 应用场景：
// 流体模拟：这个着色器可用于流体模拟中的速度场更新，特别是模拟涡旋、涡流等旋转力场的影响。例如，在水、气体、烟雾等流体的模拟中，卷曲是描述旋转和涡流的一个关键参数。

// 气象模拟：在大气模拟中，卷曲通常与气旋、龙卷风等气象现象相关。此着色器能够根据卷曲场更新速度场，进而模拟风场等现象。

// 游戏开发和可视化：此着色器也可以用于生成逼真的旋转效果和涡旋效果，如水流、旋涡、飓风等视觉效果。

// 改进和优化：
// 稳定性：length(force + 0.00001) 的添加是为了避免除以零的情况，但在某些情况下，可能需要更精细的控制来避免数值不稳定。可以考虑增加一个最小值（比如 0.0001）来确保力的大小始终不为零。

// 力的方向：目前的力计算是基于卷曲值的上下差异，可以考虑增加对横向差异的处理，或根据卷曲的方向来调整力的方向。

// 效率优化：可以通过避免多次纹理采样（例如 uCurl 和 uVelocity 的重复采样）来提高效率。